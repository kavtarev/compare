Здравствуйте, меня зовут Иван я бэкенд разработчик на проекте мониторинга.
Сейчас я расскажу вам про техническую сторону проекта.

# Общая информация
  На данном слайде представлен стэк технологий использованных в проекте.
Он стандартный для большинства команд. Приложение на nodejs с использованием 
фреймворка nest. База данных постгрес и редис. Логирование через елк. Переменные во волт.

  Отметить хочется несколько моментов.
Первое. Так как проект разрабатывался с нуля, была возможность использовать последние версии технологий. Что дает приятные мелочи для ускорения разработки, ускорение работы проекта и большие гарантии безопасности.

В частности в 22 node доработали модуль для тестирования и сама она стала быстрее.

К вопросу безопасности. Наши друзья девопсы вкрутили в ci такую вещь как Gemnasium - 
показывающую известные уязвимости в библиотеках проекта. Обычно это какие-то крайние случаи так называемые corner case но мы все равно стараемся их устранять.

Так же хочется отметить что наш проект поднят в кубернетисе и по тз каждый из сервисов поднят в двух экземплярах.

Справа схематично изображено кто и как общается. В целом все стандартно и сервисы общаются между собой и через rabbit и через http.

В Процессе разработки мы сталкивались в различными сложностями, как в вопросах интеграций так и в технических аспектах разработки. Про это чуть подробнее.

# Интеграция с 1С

На этом слайде представлены некоторые особенности работы с 1с.
Есть поговорка что в программировании есть две основные проблемы: инвалидация кэша и названия переменных. Человек придумавший ее не работал с интеграций 1с.

На левом нижнем слайде - пример выполнения запроса на получение данных от 1с. Как можете заметить ответа мы ждали двадцать одну с половиной минуту. Так долго происходит не всегда, вероятно зависит от количества данных.

На левом верхнем слайде вы можете увидеть предметы лизинга у которых значение их vin находится в колонке серийного номера. При этом отмечу что это валидные вины они есть в системе и по ним должен работать мониторинг.

На правом верхнем слайде можете увидеть что у нас 2319 предметов лизинга у которых в вине русские буквы. Иногда там будет валидный вин, написанный транслитом, а иногда там будет просто случайный текст на русском вроде адреса.

На правом нижнем слайде можете увидеть что вин есть даже у предметов мебели

Мы с командой долго думали почему так происходит и как это назвать одним словом. На вопрос почему - ответ на экране. Как это назвать одним словом - каждый из вас вправе решать самостоятельно.

# Интеграция с X-KEEPER

Вот моменты работы с X-KEEPER.

Что здесь происходит. Мы делаем запросы в X-KEEPER по одному и тому-же номеру сим карты.
Это сим карта маячка установленного на предмете. Как вы может заметить в ответах от
X-KEEPER хэш устройства разный. Получается что один и тот же маячок установлен сразу на двух предметах. И это именно 2 предмета потому что данные полученные через такие запросы и данные полученные через админку X-KEEPER - не совпадают.

На одном устройстве могут быть установлены сразу 2 маячка. На них будут разные симки. Здесь нет этого слайда, но мы находили случай когда первый маячок показывается в центре города, а другой в нескольких километрах от первого, в реке.
Может сбой геолокации а может было жарко и маячок устал и пошел купаться. Ответа мы так и не нашли.

Так как данные в X-KEEPER попадают из 1с то и в ответах X-KEEPER будут вины с русскими буквами
По крайней мере они в переписке утверждают именно так.

Особый шарм этому придает то что с KEEPER интегрируются все в гпбл. Выводы предлагаю сделать вам самим.

# Интеграция с Контур Фокусом

Перед вами еще один пример прекрасного. Сверху показана запись в БД полученная из 1с
А снизу ответы КФ по поиску по огрн и по инн. Как вы видите по огрн и по инн находятся разные записи, хотя в 1с они принадлежат одному контрагенту.

Как небольшой вывод по первым трём слайдам. На самом деле таких случаев было больше, но во всем нужно знать меру. Все эти проблемы/расхождения появлялись постепенно
и влекли за собой как переписку с интеграциями так и аналитическую работу с изменением логики работы.

# Мы

На последних двух слайдах речь идет про наши просчеты и про пару техническим моментов.

У postgres есть придел количества аргументов - это тем самые $1 $2 и тд которые мы используем, в частности, для защиты от sql инъекций. Этот лимит равен 65535. Слева в верху пример вставки сущностей через орм. Несложно заметить, что вставка 10к элементов по 7 значений в каждом - взорвется.

Аналогично у рэбита есть ограничение на размер сообщения в 128мб и если после вставки вы обогатите данные и пошлете их в рэббит, то сложится еще и он.

На начальном этапе - когда вам присылают данные десятками это не вылезает. Но это мина в вашем проэкте. Держите в голове и не забывайте чанковать.

Чуть-чуть про кубер и работу с ним.

Сама по себе нода довольно прожорлива по памяти, поэтому когда наши друзья девопсы выделяют 128мб на инстанс, а вам прилетает много данных - все сложится с ООМ. Решение - оптимизировать алгоритмы на расход памяти, чанковать не использовать орм. Потом сдаться и попросить девопсов увеличить память до 256. Потому, что много мб - это много мб и хоть как ты тут буть.

Как было сказано ранее каждый сервис поднят в кубере в двух инстансах. Сделано это по требованию заказчика. Это рождает специфическую проблему. Если в ваших сервисах есть крон джобы то они будут запускаться в обоих сервисах и как следствие дублироваться. Оба сервиса подняты в качестве мастера. По этому было принято решение синхронизировать их через механизм локов в redis. По сути вы как обычно устанавливаете переменную но только с флагом NX то есть нот экзист. Это значит что только в первый раз эта установка вернет ответ 'ok' в дальнейшие разы ответом будет null.

И последние про кубер - это механизм хелсчеков. Раз в 10 секунд мы проверяем что сервис жив.
Нода однопоточна и когда данных много, а вы делаете циклы в цикле - это может останавливать поток на 10+ секунд. Хелсчек не пройдет, кубер перезапустит приложение. Не надо так.

Последний слайд про ускорение работы системы путем отказа от орм. Один и тот же кода написанный на орм и на чистом sql. Как можно заметить разница в 30 раз. Это пример того что неправильный выбор инструмента может свести на нет все другие оптимизации.